#version 450

float hash(float n) {
    return fract(sin(n) * 43758.5453123);
}

struct Vertex {
	vec3 pos;
	vec3 norm;
	vec3 color;
};

struct Wave {
    float amp;
	float freq;
    float speed;
    float angle;
};

vec2 polarToCartesian(float r, float theta) {
    float x = r * cos(theta);
    float y = r * sin(theta);
    return vec2(x, y);
}

layout(std140, binding = 0) uniform ParameterUBO {
	vec3 eye;
	mat4 model;
	mat4 view;
	mat4 invView;
	mat4 normalMat;
	mat4 proj;
	float t;
} ubo;

layout(std140, binding = 1) readonly buffer VertexSSBOIn {
	Vertex verticesIn[ ];
};

layout(std140, binding = 2) buffer VertexSSBOOut {
	Vertex verticesOut[ ];
};

layout(std140, binding = 3) readonly buffer WaveSSBO {
	Wave Waves[ ];
};

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

void main() {
	uint index = gl_GlobalInvocationID.x;

	Vertex vertexIn = verticesIn[index];

	float waveTerm = 0.0;
	float waveHeight = 0.0;
	float partialWaveX = 0.0;
	float partialWaveZ = 0.0;
	float partialHeightX = 0.0;
	float partialHeightZ = 0.0;
	float sumOfWeights = 0.0;
	vec2 sampleVertex = vec2(verticesIn[index].pos.x, verticesIn[index].pos.z);
	for (int i = 0; i < 4; i++) {
		vec2 waveDir = polarToCartesian(1.0, Waves[i].angle);
		//vec2 sampleVertex = vec2(verticesIn[index].pos.x, verticesIn[index].pos.z);
		//vec2 sampleVertex = vec2(verticesIn[index].pos.x + partialWaveX, verticesIn[index].pos.z + partialWaveZ);

		//float arg = dot(waveDir, sampleVertex) * Waves[i].freq + ubo.t*Waves[i].speed + (length(sampleVertex) * 0.1);

		float arg = dot(waveDir, sampleVertex) * Waves[i].freq + ubo.t*Waves[i].speed*Waves[i].freq;

		waveTerm = Waves[i].amp * exp( sin( arg ) - 1.0 );
		waveHeight += waveTerm;

		partialWaveX = waveDir.x * Waves[i].freq * Waves[i].amp * cos( arg ) * waveTerm;
		partialWaveZ = waveDir.y * Waves[i].freq * Waves[i].amp * cos( arg ) * waveTerm;
		
		partialHeightX += partialWaveX;
		partialHeightZ += partialWaveZ;

		sampleVertex += waveDir * partialWaveX * Waves[i].amp * 0.38; // 0.38 is the drag multiplier

		sumOfWeights += Waves[i].amp;
	}
	waveHeight /= sumOfWeights;

	verticesOut[index].pos = vec3(verticesIn[index].pos.x, waveHeight, verticesIn[index].pos.z);
	verticesOut[index].norm = normalize(vec3( -partialHeightX, 1.0, -partialHeightZ ));
	verticesOut[index].color = verticesOut[index].norm;
}
