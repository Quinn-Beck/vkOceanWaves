#version 450

float hash(float n) {
    return fract(sin(n) * 43758.5453123);
}

struct Vertex {
	vec3 pos;
	vec3 norm;
	vec3 color;
};

struct Wave {
    float amp;
	float freq;
    float speed;
    float angle;
};

vec2 polarToCartesian(float r, float theta) {
    float x = r * cos(theta);
    float y = r * sin(theta);
    return vec2(x, y);
}

layout(std140, binding = 0) uniform ParameterUBO {
	mat4 model;
	mat4 view;
	mat4 proj;
	float t;
} ubo;

layout(std140, binding = 1) readonly buffer VertexSSBOIn {
	Vertex verticesIn[ ];
};

layout(std140, binding = 2) buffer VertexSSBOOut {
	Vertex verticesOut[ ];
};

layout(std140, binding = 3) readonly buffer WaveSSBO {
	Wave Waves[ ];
};

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

void main() {
	uint index = gl_GlobalInvocationID.x;

	Vertex vertexIn = verticesIn[index];

	float waveTerm = 0.0;
	float waveHeight = 0.0;
	float partialWaveX = 0.0;
	float partialWaveZ = 0.0;
	float partialHeightX = 0.0;
	float partialHeightZ = 0.0;
	for (int i = 0; i < 6; i++) {
		vec2 waveDir = polarToCartesian(1.0, Waves[i].angle);
		vec2 sampleVertex = vec2(verticesIn[index].pos.x + partialWaveX, verticesIn[index].pos.z + partialWaveZ);

		waveTerm = exp( Waves[i].amp * sin( dot(waveDir, sampleVertex) + ubo.t*Waves[i].speed * Waves[i].freq ) - 1.0 );
		waveHeight += waveTerm;

		partialWaveX = Waves[i].amp * waveDir.x * Waves[i].freq * cos( dot(waveDir, sampleVertex) + ubo.t*Waves[i].speed * Waves[i].freq ) * waveTerm;
		partialWaveZ = Waves[i].amp * waveDir.y * Waves[i].freq * cos( dot(waveDir, sampleVertex) + ubo.t*Waves[i].speed * Waves[i].freq ) * waveTerm;
		partialHeightX += partialWaveX;
		partialHeightZ += partialWaveZ;


	}

	verticesOut[index].pos = vec3(verticesIn[index].pos.x, waveHeight, verticesIn[index].pos.z);
	verticesOut[index].norm = normalize(vec3( -partialHeightX, 1, -partialHeightZ ));
	verticesOut[index].color = verticesOut[index].norm;
}
